
# 정렬

order by 칼럼명 (asc) ;

order by 칼럼명 desc;

null은 오름차순에서 가장 마지막에 옴



# 제약조건

| 무결성 제약조건 | 역할 |
| ---- | ---- |
| NOT NULL | NULL을 허용 X |
| UNIQUE | 중복된 값을 허용 X 항상 유일한 값 NULL 허용 |
| PRIMARY KEY | NOT NULL + UNIQUE (기본키) (부모키) |
| FOREIGN KEY | 참조되는 테이블의 칼럼의 값이 존재하면 허용 (자식키) |
| CHECK | 저장 가능한 데이터의 값의 범위나 조건을 지정하여 설정한 값만을 허용 |

![[Pasted image 20240118102143.png]]

select constraint_name, constraint_type, table_name, search_condition, R_CONSTRAINT_NAME
     from USER_CONSTRAINTS natural JOIN USER_CONS_COLUMNS;

![[Pasted image 20240118102238.png]]
 

SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE, R_CONSTRAINT_NAME, SEARCH_CONDITION FROM USER_CONSTRAINTS WHERE TABLE_NAME IN('EMP','DEPT');

SELECT *	FROM USER_CONS_COLUMNS WHERE TABLE_NAME IN('EMP','DEPT');



desc user_constraints; 제약 조건 확인

unique  null은 중복으로 들어갈수 잇음
select* 
from user_cons_columns;  어떤 칼럼에 제약 조건이 있는지 보기

primary key = not null + unique

부모 키가 되기위한 칼럼은 반드시 부모 테이블의 primary key 나 unique로 설정되어야함

부모테이블이 지워지면 삭제되게 할려면  ON DELETE CASCADE
CREATE TABLE CHILD2(
  2  C_ID NUMBER(2),
  3  CONSTRAINT CHILD2_ID_FK FOREIGN KEY (C_ID)
  4  REFERENCES PARENT2(P_ID) ON DELETE CASCADE);



 **제약조건 확인하는 예제**

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, COLUMN_NAME,R_CONSTRAINT_NAME
FROM  USER_CONSTRAINTS NATURAL JOIN USER_CONS_COLUMNS
where table_name in ('EMP','DEPT');

create table emp06 (
empno number(4)
constraint emp06_empno_pk primary key,
ename varchar2(10) 
constraint emp06_empno_nn not null,
job varchar2(9),
deptno number(2) 
constraint emp06_deptno_fk references dept(deptno)
);

create table emp07(
	empno number(4)
		constraint emp07_empno_pk primary key,
	ename varchar2(10)
		constraint emp07_ename_nn not null,
	sal number(7,2)
		constraint emp07_sal_ck
		check(sal between 500 and 5000),
	gender varchar2(1)
		constraint emp07_gender_ck
		check(gender in('M','F'))

SELECT TABLE_NAME, CONSTRAINT_TYPE, 
CONSTRAINT_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP07');


----

default 제약조건을 걸면 입력하지 않아도 값이 들어가짐

자식 테이블을 지우고
부모 테이블을 지워야함

부모 테이블 부터 지울려면  
drop table 부모 테이블 이름 casecade constraints;


제약조건을 확인하기
# SQL 함수

abs( 숫자)절대값 

floor ( 숫자) n이하의 가장 큰정수 반환

round ( 숫자,자릿수 )  반올림 

trunc (숫자, 자릿수) 지정한 자릿수 이하 버리기

mod (숫자, 나눌 숫자) 나머지 출력

lower (’문자열’) 소문자로 변경

upper (’문자열’) 대문자로 변경

initcap (’문자열’) 문자열의 이니셜만 대문자로 변경

length(); 문자열길이

lengthb(); 문자열 길이의 바이트

substr(대상, 시작위치, 추출할 개수) 시작위치가 음수면 뒤에서 부터 

칼럼 LIKE 와일드 카드 패턴  정확한 문자열을 몰라도검색 기능 

와일드 카드 패턴은 

% 문자가없거나,하나이상의문자가어떤값이와도상관없다.

_ 하나의문자가어떤값이와도상관없다

“칼럼” like ‘_S%’   두번째 자리에 S가 오는 모든 칼럼 

instr (’문자열’,’찾을 문자열’,시작위치,몇번째) 찾을 문자열의 위치를 알려줌

LPAD (’문자열’, 갯수,’기호’) 왼족부터 패딩

rpad

LTRIM(’문자열’) 앞쪽 공백 제어

replace(’문자열 또는 컬럼명’, 문자1, 문자2)

문자 1이랑 문자2를 바꿔라

nvl(e1 ,e2 ) e1값이 null이면 e2 값출력  아니면 e1값 출력

|| 문자열 연결

cube(그룹1, 그룹2) 모든 조합별로 총합을 나타냄

rollup (그룹1, 그룹2) 그룹1만 값을 더해줌

LISTAGG(컬럼명1, 구분자) WITHIN GROUP (ORDER BY 정렬할컬럼)  

decode ( 컬럼명, 조건1, 결과1,

조건2, 결과2,)

조건1이면 결과1 출력

case ( 컬럼명, when조건1 then결과1

when조건2 then결과2

end as dname)

case는 다양한 연산자 사용가능

between a and b :   a와 b 사이

not between a and b :   a와 b 사이를 제외한

join 한개이상의 테이블에서 조회하는것

union (합집합)  열의 갯수가 같아야함 중복데이터는 제거됨, 자료형이 같아야함 (union all 쓰면 중복도 표시)

intersect (교집합) 중복행은 하나의 결과만 보여줌

MINUS(차집합)

drop table 테이블명 purge >all  최대값

     >any 최소값

alter table 테이블명 (컬럼추가) 원하는 위치에 불가능

add  칼럼명 데이터;

truncate table 테이블명  모든 로우 제거  (DDL 자동 커밋 삭제이전으로 롤백 불가)

where 1 = 0 ; ( 구조만 생성)


# DML

insert into 테이블명 (데이터 추가)

(칼럼 명) 갯수를 맞춰야함

values ( 넣을 값)

insert all

when 조건

update 테이블명

set 칼럼명 = 값, 칼럼명2 = 값2

where 조건 

조건을 안쓰면 모두 바뀜

delete 테이블명 (데이터 삭제)

Contentwhere 조건


merge(합병) 구조가 같은 테이블을 하나의 테이블로 합치기

![[Pasted image 20240117120020.png]]


# join

inner join  제한된 내용만 조인
right outter join 오른쪽 내용이 초과 하는것도 조인
left outter join 왼쪽 내용이 초과 하는것도 조인
full outter join 양쪽 다 초과하는 것도 조인
